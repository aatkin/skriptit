(ns skriptit.rems
  (:require [babashka.fs :as fs]
            [babashka.http-client :as http]
            [clojure.string :as str]
            [skriptit.cli :refer [shell* shell-str]]
            [skriptit.utils :as utils]))

;; code generated by ChatGPT v3.5. incredible times
(defn- rems-tag
  "Print commands for creating git tag with release number from current changelog."
  {:skriptit/cmd "tag"}
  [& _cli-args]
  (let [changelog (slurp "CHANGELOG.md")
        release-version (second (re-find #"## (v[\d.]+)" changelog))
        release-name (second (re-find #"## v[\d.]+ \"([^\"]+)\"" changelog))
        tag-command (str "git tag -a " release-version
                         " -m \"Release " release-version
                         ", \\\"" release-name "\\\"\"")]
    (println tag-command)))

(defn- release-branch
  "Print CLI commands for doing REMS release."
  {:skriptit/cmd "release"}
  [& _cli-args]
  (let [version (-> (shell-str "git describe"
                               "--tags"
                               "--abbrev=0")
                    :out
                    str/split-lines
                    first)
        major (->> version (re-find #"v[\d].+") second utils/parse-int)
        minor (->> version (re-find #"v\d\.(.+)") second utils/parse-int inc)
        branch (str "release-" major "." minor)]
    (println (pr-str {:current version
                      :next (str "v" major "." minor)}))
    (println "create branch:" branch)))

;; #!/bin/bash
;; docker run --rm --name rems_test -p 127.0.0.1:5432:5432 -d -e POSTGRES_HOST_AUTH_METHOD=trust postgres:13
;; docker run --rm --link rems_test postgres:13 /bin/bash -c "while ! psql -h rems_test -U postgres -c 'select 1;' 2>/dev/null; do sleep 1; done"
;; docker run -i --rm --link rems_test postgres:13 psql -h rems_test -U postgres < resources/sql/init.sql

;; ARGS="run dev-setup"

;; # optionally run perf test data
;; if [ "$1" == "perf" ]; then
;;     ARGS="run perf-setup"
;; fi

;; echo "lein $ARGS"
;; lein $ARGS

(defn- docker-volumes
  "Columns: `[driver volume-name]`"
  []
  (->> (shell-str "docker volume ls")
       :out
       str/split-lines
       (map #(str/split % #"[\s]{2,}"))))

(defn- volume-exists? [volume-name]
  (let [volumes (->> (docker-volumes)
                     (into #{} (map second)))]
    (contains? volumes volume-name)))

(defn- docker-containers
  "Columns: `[container-id image command created status ports names]`
   
   Opts:
   - `:all?` (optional) Show all containers (default shows just running)"
  [& [{:keys [all?]}]]
  (->> (shell-str (cond-> "docker container ls"
                    all? (str " --all")))
       :out
       str/split-lines
       (map #(str/split % #"[\s]{2,}"))))

(defn- container-exists? [container-id]
  (let [containers (->> (docker-containers {:all? true})
                        (into #{} (map last)))]
    (contains? containers container-id)))

(defn- container-running? [container-id]
  (let [containers (->> (docker-containers)
                        (into #{} (map last)))]
    (contains? containers container-id)))

(comment
  (docker-containers {:all? true})
  (container-exists? "rems_test")

  (docker-containers)
  (container-running? "rems_test"))

(def volume-name "skriptit-rems-db-volume")
(def container-id "rems_test")
(def container-hostname "rems_test")
(def postgres-image "postgres:13")
(def db-init-script
  (let [dir (fs/file (utils/resource "rems" "db"))
        init-script (fs/file dir "init.sql")
        github-url "https://raw.githubusercontent.com/CSCfi/rems/master/resources/sql/init.sql"]
    (delay
      (fs/create-dirs (fs/path dir))
      (some->> (:body (http/get github-url))
               (spit (str (fs/path init-script))))
      (utils/chmod-file dir [7 5 5])
      (utils/chmod-file init-script [6 4 4])
      (str (fs/path init-script)))))

(defn- rems-db
  "Start postgres:13 container for rems-dev local database. Creates new volume if not exists."
  {:skriptit/cmd "db"}
  [& _cli-args]
  (when-not (volume-exists? volume-name)
    ;; https://docs.docker.com/reference/cli/docker/volume/create/
    ;; usage: docker volume create [OPTIONS] [VOLUME]
    (shell* "docker volume create" volume-name)
    (assert (volume-exists? volume-name)))

  ;; https://docs.docker.com/reference/cli/docker/container/create/
  ;; usage: docker container create [OPTIONS] IMAGE [COMMAND] [ARG...]
  (when-not (container-exists? container-id)
    (shell* "docker container create"
            ;; [OPTIONS]
            ;; Assign a name to the container
            "--name" container-id
            ;; Container host name
            "--hostname" container-hostname
            ;; --volume Bind mount a volume
            "-v" (str volume-name ":/var/lib/postgresql/data")
            ;; --publish Publish a container's port(s) to the host
            "-p" "127.0.0.1:5432:5432"
            ;; --env Set environment variables
            "-e" "POSTGRES_HOST_AUTH_METHOD=trust"
            ;; IMAGE
            postgres-image)
    (println "container exists?" (container-exists? container-id))

    (shell* "docker container start" container-id)
    (println "container running?" (container-running? container-id))

    (assert (fs/exists? (fs/file @db-init-script)))
    (println "init script path" @db-init-script)
    ;; docker container cp ./resources/rems/db/init.sql rems_test:/docker-entrypoint-init.db.d
    (shell* "docker container cp"
            ;; [OPTIONS]
            ;; SRC_PATH
            @db-init-script
            ;; DEST_PATH
            (format "%s:/docker-entrypoint-initdb.d" container-id))

    ;; docker run --rm --link rems_test postgres:13 /bin/bash -c "while ! psql -h rems_test -U postgres -c 'select 1;' 2>/dev/null; do sleep 1; done"
    ;; wait for postgres to start
    (shell* "docker container exec"
            ;; [OPTIONS]
            "--interactive"
            ;; CONTAINER
            container-id
            ;; COMMAND
            "/bin/bash"
            ;; [ARG...]
            "-c" (format "while ! psql -h %s -U postgres -c 'select 1;' 2>/dev/null; do sleep 1; done"
                         container-hostname)))

  (when-not (container-running? container-id)
    (shell* "docker container restart" container-id)
    (assert (container-running? container-id)))

  (println (format "container id: %s\nvolume name: %s"
                   container-id volume-name)))

(defn quote-vec [& args]
  (str "[" (str/join " " (remove nil? args)) "]"))

(defn quote-str [s]
  (str "\"" s "\""))

(defn format-lein-dependency [dependency & [version]]
  (quote-vec dependency
             (some-> version quote-str)))

(def cli-deps
  {:nrepl {:name "nrepl"
           :url "https://github.com/nrepl/nrepl"
           :version "1.3.0"}

   :cider-nrepl {:name "cider/cider-nrepl"
                 :url "https://github.com/clojure-emacs/cider-nrepl"
                 :version "0.50.1"}})

(defn lein-dep [k]
  (let [dep (get cli-deps k)]
    (format-lein-dependency (:name dep) (:version dep))))

(defn shadow-dep [k]
  (let [dep (get cli-deps k)]
    (str (:name dep) ":" (:version dep))))

;; XXX: this could be generic (leiningen) script to add nREPL dependencies?
(defn- rems-dev
  "Start REMS dev process with nREPL. Does not automatically load any REMS namespaces (e.g. no server startup)."
  {:skriptit/cmd "dev"
   :skriptit/args "& :extra-profiles]"}
  [& extra-profiles]
  (let [plugins ["update-in" :plugins
                 "conj" (lein-dep :cider-nrepl)]
        repl-cider ["update-in" (quote-vec :repl-options :nrepl-middleware)
                    "conj" (quote-vec "cider.nrepl/cider-middleware")]
        profiles (->> extra-profiles
                      (into ["+dev"])
                      (str/join ","))
        cmd ["with-profile" profiles "repl" :headless]]
    (apply shell* "lein" (->> cmd
                              (list plugins repl-cider)
                              (interpose ["--"])
                              (flatten)))))

(defn- rems-shadow
  "Start shadow-cljs watcher for REMS front-end."
  {:skriptit/cmd "shadow"}
  [& _cli-args]
  (let [repl-options ["-d" (shadow-dep :cider-nrepl)]
        cmd ["npx" "shadow-cljs" repl-options "watch" ":app"]]
    (apply shell* (flatten cmd))))

(defn- rems-test
  "Run REMS tests with kaocha (backend) test runner."
  {:skriptit/cmd "test"
   :skriptit/args ":target & :args"}
  [target & args]
  (let [opts (set args)
        statistics (seq (filter #{"--stats" "--statistics"} opts))
        watch (seq (filter #{"-w" "--watch"} opts))
        profiles (filter #(str/starts-with? % "+skriptit-") opts)
        rest-opts (->> (concat profiles statistics watch)
                       (remove nil?)
                       (apply disj opts))
        kaocha-runner ["with-profile" (str/join "," (cons "+test" profiles))
                       "run" "-m" "kaocha.runner"]]
    (cond
      (some #{target} #{"integration" ":integration"
                        "unit" ":unit"
                        "browser" ":browser"})
      (apply shell*
             "lein"
             (cond-> [target]
               true (->> (into kaocha-runner))
               statistics (into ["--plugin" "rems.kaocha/cache-statistics-plugin"])
               true (into ["--reporter" "kaocha.report/documentation"])
               watch (into ["--watch" "--fail-fast"])
               (seq rest-opts) (into rest-opts)))

      (str/starts-with? target ":") ; cmd: lein with-profile +test run -m kaocha.runner --focus rems.test-cache --plugin rems.kaocha/cache-statistics-plugin --reporter kaocha.report/documentation --watch --fail-fast
      (apply shell*
             "lein"
             (cond-> ["--focus-meta" target]
               true (->> (into kaocha-runner))
               statistics (into ["--plugin" "rems.kaocha/cache-statistics-plugin"])
               true (into ["--reporter" "kaocha.report/documentation"])
               watch (into ["--watch" "--fail-fast"])
               (seq rest-opts) (into rest-opts)))

      :else ; cmd: lein with-profile +test run -m kaocha.runner --focus rems.test-cache --reporter kaocha.report/documentation --watch --fail-fast
      (apply shell*
             "lein"
             (cond-> ["--focus" target]
               true (->> (into kaocha-runner))
               statistics (into ["--plugin" "rems.kaocha/cache-statistics-plugin"])
               true (into ["--reporter" "kaocha.report/documentation"])
               watch (into ["--watch" "--fail-fast"])
               (seq rest-opts) (into rest-opts))))))
